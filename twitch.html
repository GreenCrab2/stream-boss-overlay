<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Twitch Bridge + Stream Boss</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{
      margin:0;
      padding:12px;
      font-family:system-ui,Segoe UI,Inter,Roboto,sans-serif;
      background:#050509;
      color:#f5f5ff;
    }
    .top{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      margin-bottom:10px;
    }
    button{
      cursor:pointer;
      padding:8px 12px;
      border-radius:8px;
      border:1px solid #333644;
      background:#1f2230;
      color:#fff;
      font-weight:600;
    }
    button:active{ transform:translateY(1px); }
    #gUser{
      opacity:.85;
      margin-left:6px;
      font-size:13px;
    }
    pre{
      margin:0;
      padding:10px;
      border-radius:10px;
      border:1px solid #2a2d3a;
      background:#0b0d16;
      font-size:13px;
      line-height:1.45;
      white-space:pre-wrap;
    }
    code{
      padding:2px 4px;
      border-radius:4px;
      background:#111320;
      border:1px solid #333644;
      font-size:12px;
    }
  </style>
</head>
<body>
  <div class="top">
    <button id="twLogin">Войти в Twitch</button>
    <button id="twReset">Сбросить токен</button>
    <button id="gLogin">Войти в Google (Firebase)</button>
    <span id="gUser"></span>
  </div>

  <pre id="log"></pre>

  <script type="module">
    /**************  НАСТРОЙКИ  **************/
    const CLIENT_ID     = 'l8kchqfp0vdlva741gcj6hkvkw08jb';           // Twitch Client ID
    const REDIRECT_URI  = location.origin + location.pathname;        // Должен совпадать с OAuth Redirect URL в консоли Twitch
    const SCOPES        = ['channel:read:redemptions'];               // только чтение редемпов
    const REWARD_TITLE  = 'Применить способность';                    // точное имя награды

    // Комната берётся из ?room=..., по умолчанию demo
    const ROOM_ID = new URLSearchParams(location.search).get('room') || 'demo';

    // Firebase (тот же config, что и в overlay/control)
    import { initializeApp }   from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getFirestore, doc, getDoc, updateDoc, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import {
      getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyADwdDLpb5Qb2fuDx5vWC3-_BAX4S7ZiJk",
      authDomain: "mini-app-adventure.firebaseapp.com",
      projectId: "mini-app-adventure",
      storageBucket: "mini-app-adventure.firebasestorage.app",
      messagingSenderId: "537034908749",
      appId: "1:537034908749:web:26edebdf7d9fa2b42a2804",
      measurementId: "G-0RF2PPHQN8"
    };

    const fbApp   = initializeApp(firebaseConfig);
    const db      = getFirestore(fbApp);
    const fbAuth  = getAuth(fbApp);
    const roomRef = doc(db, 'rooms', ROOM_ID);
    const gProv   = new GoogleAuthProvider();

    /**************  УТИЛИТЫ  **************/
    const logEl = document.getElementById('log');
    function log(...a){
      const line = a.map(x =>
        (typeof x === 'object' ? JSON.stringify(x) : String(x))
      ).join(' ');
      logEl.textContent += line + '\n';
      logEl.scrollTop = logEl.scrollHeight;
    }

    function bufToB64Url(buf){
      const bytes = new Uint8Array(buf);
      let str = '';
      for (const b of bytes) str += String.fromCharCode(b);
      return btoa(str).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    function randomVerifier(){
      const bytes = new Uint8Array(32);
      crypto.getRandomValues(bytes);
      return bufToB64Url(bytes);
    }
    async function sha256(str){
      const data = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest('SHA-256', data);
      return bufToB64Url(hash);
    }

    /**************  СОСТОЯНИЕ TWITCH  **************/
    let twitchToken = null;   // {access_token, expires_at, refresh_token?...}
    let twitchUser  = null;   // {id, login, display_name}
    let rewardId    = null;   // ID награды в Channel Points
    let lastSeenTs  = Date.now();  // защита от повторной обработки

    const LS_TOKEN_KEY = 'sb_twitch_token_v1';
    const SS_VERIFIER_KEY = 'sb_twitch_pkce_verifier';

    function saveToken(t){
      twitchToken = t;
      try{ localStorage.setItem(LS_TOKEN_KEY, JSON.stringify(t)); }catch(e){}
    }
    function loadToken(){
      try{
        const raw = localStorage.getItem(LS_TOKEN_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      }catch(e){ return null; }
    }
    function clearToken(){
      twitchToken = null;
      twitchUser  = null;
      rewardId    = null;
      try{ localStorage.removeItem(LS_TOKEN_KEY); }catch(e){}
    }

    /**************  TWITCH OAUTH (PKCE)  **************/
    async function startTwitchLogin(){
      const verifier  = randomVerifier();
      const challenge = await sha256(verifier);
      sessionStorage.setItem(SS_VERIFIER_KEY, verifier);

      const params = new URLSearchParams({
        response_type: 'code',
        client_id: CLIENT_ID,
        redirect_uri: REDIRECT_URI,
        scope: SCOPES.join(' '),
        state: 'sb_' + Math.random().toString(36).slice(2),
        code_challenge_method: 'S256',
        code_challenge: challenge
      });
      const url = `https://id.twitch.tv/oauth2/authorize?${params.toString()}`;
      location.href = url;
    }

    async function exchangeCodeForToken(code){
      const verifier = sessionStorage.getItem(SS_VERIFIER_KEY);
      if (!verifier){
        log('Ошибка: PKCE verifier не найден. Попробуй «Сбросить токен» и войти заново.');
        return;
      }

      const body = new URLSearchParams({
        client_id: CLIENT_ID,
        grant_type: 'authorization_code',
        code,
        redirect_uri: REDIRECT_URI,
        code_verifier: verifier
      });

      const r = await fetch('https://id.twitch.tv/oauth2/token', {
        method: 'POST',
        headers: { 'Content-Type':'application/x-www-form-urlencoded' },
        body
      });
      const j = await r.json();
      if (!r.ok){
        log('Ошибка обмена токена:', JSON.stringify(j));
        return;
      }

      const expiresAt = Date.now() + (j.expires_in - 60) * 1000;
      saveToken({
        access_token: j.access_token,
        refresh_token: j.refresh_token || null,
        expires_at:   expiresAt,
        scope: j.scope || SCOPES
      });
      log('Twitch: токен получен, срок ~', Math.round(j.expires_in/60), 'мин.');

      // убираем ?code= из URL
      const url = new URL(location.href);
      url.searchParams.delete('code');
      url.searchParams.delete('state');
      history.replaceState({}, '', url.toString());

      await initWithToken();
    }

    async function validateToken(){
      const r = await fetch('https://id.twitch.tv/oauth2/validate', {
        headers: { 'Authorization':'OAuth ' + twitchToken.access_token }
      });
      if (!r.ok) throw new Error('validate failed: ' + r.status);
      return r.json();
    }

    /**************  TWITCH API (Helix)  **************/
    async function initWithToken(){
      if (!twitchToken) return;

      // проверяем срок действия
      if (twitchToken.expires_at && Date.now() > twitchToken.expires_at){
        log('Twitch: токен устарел, нужно войти заново.');
        return;
      }

      try{
        const v = await validateToken();
        log('Token scopes:', v.scopes.join(', '));
      }catch(e){
        log('Не удалось валидировать токен:', e.message||e);
        return;
      }

      // получаем инфу о пользователе
      const userRes = await fetch('https://api.twitch.tv/helix/users', {
        headers:{
          'Client-Id': CLIENT_ID,
          'Authorization':'Bearer ' + twitchToken.access_token
        }
      });
      const userJson = await userRes.json();
      if (!userRes.ok || !userJson.data || !userJson.data[0]){
        log('Не получилось получить /helix/users:', JSON.stringify(userJson));
        return;
      }
      twitchUser = userJson.data[0];
      log(`Twitch: ${twitchUser.display_name} (id ${twitchUser.id})`);

      // ищем нужную награду
      rewardId = await findRewardId(twitchUser.id);
      if (!rewardId){
        log(`Награда "${REWARD_TITLE}" не найдена. Создай её в Channel Points и обнови страницу.`);
        return;
      }

      log(`Готово: ждём редемпы «${REWARD_TITLE}» в комнате "${ROOM_ID}".`);
      startRedemptionPolling();
    }

    async function findRewardId(broadcasterId){
      const url = new URL('https://api.twitch.tv/helix/channel_points/custom_rewards');
      url.searchParams.set('broadcaster_id', broadcasterId);

      const r = await fetch(url.toString(), {
        headers:{
          'Client-Id': CLIENT_ID,
          'Authorization':'Bearer ' + twitchToken.access_token
        }
      });
      const j = await r.json();
      if (!r.ok){
        log('Ошибка получения списка наград:', JSON.stringify(j));
        return null;
      }
      const list = j.data || [];
      const wanted = (REWARD_TITLE || '').trim().toLowerCase();
      const found = list.find(r => (r.title || '').trim().toLowerCase() === wanted);
      if (found){
        log('Helix: reward id =', found.id);
        return found.id;
      }
      return null;
    }

    // Периодический опрос Helix разными статусами
    const STATUSES = ['UNFULFILLED', 'FULFILLED'];
    let pollTimer = null;

    function startRedemptionPolling(){
      lastSeenTs = Date.now();      // запоминаем момент запуска
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = setInterval(pollRedemptions, 5000);
      // сразу один вызов, чтобы не ждать 5 секунд
      pollRedemptions();
    }

    async function pollRedemptions(){
      if (!twitchToken || !twitchUser || !rewardId) return;

      for (const status of STATUSES){
        try{
          const url = new URL('https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions');
          url.searchParams.set('broadcaster_id', twitchUser.id);
          url.searchParams.set('reward_id', rewardId);
          url.searchParams.set('status', status);
          url.searchParams.set('first', '50');

          const r = await fetch(url.toString(), {
            headers:{
              'Client-Id': CLIENT_ID,
              'Authorization':'Bearer ' + twitchToken.access_token
            }
          });
          const j = await r.json();
          if (!r.ok){
            // не спамим лог каждую секунду
            log('Helix poll error:', status, JSON.stringify(j));
            continue;
          }

          const arr = j.data || [];
          if (!arr.length) continue;

          const fresh = arr.filter(red => {
            const ts = Date.parse(red.redeemed_at || red.timestamp || '');
            return ts && ts > lastSeenTs;
          });

          if (!fresh.length) continue;

          fresh.sort((a,b)=> Date.parse(a.redeemed_at)-Date.parse(b.redeemed_at));
          for (const red of fresh){
            lastSeenTs = Math.max(lastSeenTs, Date.parse(red.redeemed_at));
            log(`Helix: новое погашение от ${red.user_name} (status=${status})`);
            await handleRedemption();
          }
        }catch(e){
          log('Poll exception:', status, e.message||e);
        }
      }
    }

    /**************  FIREBASE: СЛУЧАЙНЫЙ СКИЛЛ  **************/
    async function handleRedemption(){
      try{
        const snap = await getDoc(roomRef);
        if (!snap.exists()){
          log('Firestore: комната не найдена:', ROOM_ID);
          return;
        }
        const d = snap.data();
        const actions = Array.isArray(d.actions) ? d.actions : [];

        // первые 5, только валидные
        const pool = actions
          .slice(0,5)
          .filter(a => a && typeof a.dmg === 'number' && a.dmg !== 0 && a.label);

        if (!pool.length){
          log('Firestore: нет настроенных быстрых действий (actions[0..4]).');
          return;
        }

        const idx = Math.floor(Math.random() * pool.length);
        const chosen = pool[idx];
        const amount = Math.abs(chosen.dmg|0) || 1;

        log(`Команда → "${chosen.label}" (−${amount} HP)`);

        await updateDoc(roomRef, {
          cmd: {
            type:  'damage',
            amount: amount,
            at:    serverTimestamp()
          }
        });
      }catch(e){
        log('Firestore error:', e.message||e);
      }
    }

    /**************  GOOGLE LOGIN (для Firestore)  **************/
    const gLoginBtn = document.getElementById('gLogin');
    const gUserSpan = document.getElementById('gUser');

    gLoginBtn.onclick = () => signInWithPopup(fbAuth, gProv).catch(e=>{
      log('Google auth error:', e.message||e);
    });

    onAuthStateChanged(fbAuth, user=>{
      if (user){
        gUserSpan.textContent = `Вошли в Google: ${user.displayName || user.email}`;
      } else {
        gUserSpan.textContent = '';
      }
    });

    /**************  КНОПКИ TWITCH  **************/
    document.getElementById('twLogin').onclick = ()=> startTwitchLogin();
    document.getElementById('twReset').onclick = ()=>{
      clearToken();
      log('Токен очищен. Нажми «Войти в Twitch».');
    };

    /**************  ЗАПУСК **************/
    log('REDIRECT_URI:', REDIRECT_URI);
    log('Комната:', ROOM_ID);
    log('');

    // 1) Проверяем — вернулись ли мы с code=... после логина
    const url = new URL(location.href);
    const code = url.searchParams.get('code');
    if (code){
      log('Найден code в URL, обмениваем на токен...');
      exchangeCodeForToken(code);
    }else{
      // 2) Пытаемся взять токен из localStorage
      const saved = loadToken();
      if (saved){
        twitchToken = saved;
        log('Найден сохранённый токен, пробуем использовать его...');
        initWithToken();
      }else{
        log('Токен не найден. Нажми «Войти в Twitch».');
      }
    }
  </script>
</body>
</html>
