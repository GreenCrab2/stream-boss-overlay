<!doctype html>
<html lang="ru">
<meta charset="utf-8">
<title>Twitch Bridge → Stream Boss</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<body style="background:#0f0f14;color:#fff;font-family:system-ui;padding:16px">
  <div style="margin-bottom:10px;display:flex;gap:8px;flex-wrap:wrap">
    <!-- Twitch -->
    <button id="login"   style="padding:8px 12px;border-radius:8px;border:1px solid #3b3b48;background:#2b2b36;color:#fff;cursor:pointer">Войти в Twitch</button>
    <button id="logout"  style="padding:8px 12px;border-radius:8px;border:1px solid #3b3b48;background:#2b2b36;color:#fff;cursor:pointer">Сбросить токен</button>

    <!-- Firebase Auth -->
    <span style="width:18px"></span>
    <button id="gLogin"  style="padding:8px 12px;border-radius:8px;border:1px solid #3b3b48;background:#2b2b36;color:#fff;cursor:pointer">Войти в Google</button>
    <button id="gLogout" style="padding:8px 12px;border-radius:8px;border:1px solid #3b3b48;background:#2b2b36;color:#fff;cursor:pointer;display:none">Выйти из Google</button>
    <span id="fbWho" style="opacity:.85;align-self:center"></span>
  </div>
  <pre id="log" style="white-space:pre-wrap;line-height:1.4"></pre>

<script>
// ───────────────────────── НАСТРОЙКИ ─────────────────────────
const CLIENT_ID    = 'l8kchqfp0vdlva741gcj6hkvkw08jb';
const REDIRECT_URI = location.origin + location.pathname;
const SCOPES       = ['channel:read:redemptions'];
const REWARD_TITLE = 'Применить способность';
const ROOM_ID      = new URLSearchParams(location.search).get('room') || 'demo';

const FIREBASE_CONFIG = {
  apiKey: "AIzaSyADwdDLpb5Qb2fuDx5vWC3-_BAX4S7ZiJk",
  authDomain: "mini-app-adventure.firebaseapp.com",
  projectId: "mini-app-adventure",
  storageBucket: "mini-app-adventure.firebasestorage.app",
  messagingSenderId: "537034908749",
  appId: "1:537034908749:web:26edebdf7d9fa2b42a2804",
  measurementId: "G-0RF2PPHQN8"
};
// ─────────────────────────────────────────────────────────────

const log = (...a)=>{ const n=document.getElementById('log'); n.textContent += a.join(' ') + '\n'; };

// ───────────── Implicit Grant (Twitch) ─────────────
function parseHashToken(){
  if (!location.hash) return null;
  const p = new URLSearchParams(location.hash.slice(1));
  const token = p.get('access_token');
  if (token) {
    history.replaceState(null,'', REDIRECT_URI + (ROOM_ID?`?room=${encodeURIComponent(ROOM_ID)}`:''));
    return token;
  }
  return null;
}
function startImplicit(){
  const url = new URL('https://id.twitch.tv/oauth2/authorize');
  url.searchParams.set('client_id', CLIENT_ID);
  url.searchParams.set('redirect_uri', REDIRECT_URI);
  url.searchParams.set('response_type', 'token');
  url.searchParams.set('force_verify', 'true');
  url.searchParams.set('scope', SCOPES.join(' '));
  if (ROOM_ID) url.searchParams.set('state', 'room='+encodeURIComponent(ROOM_ID));
  location.href = url.toString();
}
document.getElementById('login').onclick  = ()=> startImplicit();
document.getElementById('logout').onclick = ()=>{
  sessionStorage.removeItem('tw_access_token');
  log('Токен Twitch очищен. Нажми «Войти в Twitch».');
};

// ───────────── Firebase lazy init + Auth UI ─────────────
let fb=null;
async function ensureFirebase(){
  if (fb) return fb;
  const appMod  = await import('https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js');
  const authMod = await import('https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js');
  const fsMod   = await import('https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js');

  const app = appMod.initializeApp(FIREBASE_CONFIG);
  const auth = authMod.getAuth(app);
  await authMod.setPersistence(auth, authMod.browserLocalPersistence);

  const db = fsMod.getFirestore(app);

  const $ = id=>document.getElementById(id);
  const who = $('fbWho'), gLogin=$('gLogin'), gLogout=$('gLogout');

  authMod.onAuthStateChanged(auth, (user)=>{
    if (user){
      who.textContent = `Вошли в Google: ${user.displayName || user.email}`;
      gLogin.style.display='none';
      gLogout.style.display='inline-block';
    } else {
      who.textContent = 'Не вошли в Google (для записи в комнату требуется вход админом).';
      gLogin.style.display='inline-block';
      gLogout.style.display='none';
    }
  });

  gLogin.onclick = async ()=>{
    try{
      const prov = new authMod.GoogleAuthProvider();
      prov.setCustomParameters({ prompt:'select_account' });
      await authMod.signInWithPopup(auth, prov);
    }catch(e){ log('Firebase auth error:', e.message); }
  };
  gLogout.onclick = ()=> authMod.signOut(auth);

  fb = { app, auth, ...authMod, db, ...fsMod };
  return fb;
}

// ───────────── Helix utils ─────────────
async function fetchUser(accessToken){
  const r = await fetch('https://api.twitch.tv/helix/users', {
    headers:{ 'Client-ID': CLIENT_ID, 'Authorization': 'Bearer '+accessToken }
  });
  const j = await r.json();
  if(!j.data?.length) throw new Error('users: пусто');
  return j.data[0];
}
async function validateToken(accessToken){
  const r = await fetch('https://id.twitch.tv/oauth2/validate', {
    headers: { 'Authorization': 'OAuth ' + accessToken }
  });
  const j = await r.json();
  if (j.client_id) log('Token scopes:', (j.scopes||[]).join(', ') || '(none)');
  return j;
}

// ───────────── EventSub WebSocket ─────────────
let esWs, esSessionId;
const seen = new Set();            // защита от дублей
const startedAt = Date.now();      // момент запуска страницы
let lastSeenAt  = startedAt;       // двигаем по мере поступления редемпов

async function connectEventSub(accessToken, broadcasterId){
  esWs = new WebSocket('wss://eventsub.wss.twitch.tv/ws');
  esWs.onopen = ()=> log('WS (EventSub): open');
  esWs.onclose= ()=> { log('WS (EventSub): close → reconnect…'); setTimeout(()=>connectEventSub(accessToken,broadcasterId), 3000); };
  esWs.onmessage = async (ev)=>{
    const msg = JSON.parse(ev.data);

    if (msg.metadata?.message_type === 'session_welcome'){
      esSessionId = msg.payload.session.id;
      log('WS (EventSub): welcome, session', esSessionId);
      await subscribeEvent(accessToken, 'channel.channel_points_custom_reward_redemption.add', { broadcaster_user_id: broadcasterId });
      log('EventSub: subscribed to redemptions');
    }

    if (msg.metadata?.message_type === 'notification'){
      const type = msg.subscription?.type;
      if (type === 'channel.channel_points_custom_reward_redemption.add'){
        const e = msg.payload?.event;
        if (!e || seen.has(e.id)) return;
        seen.add(e.id);

        const title = (e.reward?.title || '').trim();
        lastSeenAt = Math.max(lastSeenAt, Date.parse(e.redeemed_at || e.created_at || new Date().toISOString()));
        log('EventSub → Redemption:', title, 'by', e.user_name);
        if (title.toLowerCase() === REWARD_TITLE.trim().toLowerCase()){
          try{ await triggerRandomSkill(); log('→ skill triggered'); }catch(err){ log('Trigger error:', err.message); }
        }
      }
    }
  };
}
async function subscribeEvent(accessToken, type, condition){
  const r = await fetch('https://api.twitch.tv/helix/eventsub/subscriptions', {
    method:'POST',
    headers:{
      'Client-ID': CLIENT_ID,
      'Authorization':'Bearer ' + accessToken,
      'Content-Type':'application/json'
    },
    body: JSON.stringify({ type, version:'1', condition, transport:{ method:'websocket', session_id: esSessionId } })
  });
  if(!r.ok){ log('EventSub subscribe error:', await r.text()); }
}

// ───────────── PubSub (второстепенно) ─────────────
let psWs, psPing;
function connectPubSub(accessToken, broadcasterId){
  psWs = new WebSocket('wss://pubsub-edge.twitch.tv');
  psWs.onopen = ()=>{
    log('WS (PubSub): open');
    const msg = {
      type: 'LISTEN',
      nonce: Math.random().toString(36).slice(2),
      data: {
        topics: [ 'channel-points-channel-v1.' + broadcasterId ],
        auth_token: accessToken
      }
    };
    psWs.send(JSON.stringify(msg));
    psPing = setInterval(()=> psWs?.readyState===1 && psWs.send(JSON.stringify({type:'PING'})), 4*60*1000);
  };
  psWs.onclose = ()=>{
    log('WS (PubSub): close → reconnect…');
    clearInterval(psPing); psPing=null;
    setTimeout(()=>connectPubSub(accessToken,broadcasterId), 3000);
  };
  psWs.onmessage = (ev)=>{
    let data;
    try{ data = JSON.parse(ev.data) }catch{ return; }
    if (data.type === 'RESPONSE' && data.error)
      log('PubSub RESPONSE error:', data.error);
  };
}

// ───────────── Helix polling fallback (UNFULFILLED + FULFILLED since start) ─────────────
let pollTimer = null, cachedRewardId = null;

async function getRewardId(accessToken, broadcasterId){
  if (cachedRewardId) return cachedRewardId;
  const url = new URL('https://api.twitch.tv/helix/channel_points/custom_rewards');
  url.searchParams.set('broadcaster_id', broadcasterId);
  url.searchParams.set('only_manageable_rewards', 'false');
  const r = await fetch(url, { headers:{
    'Client-ID': CLIENT_ID, 'Authorization':'Bearer '+accessToken
  }});
  const j = await r.json();
  const found = (j.data||[]).find(x => (x.title||'').trim().toLowerCase() === REWARD_TITLE.trim().toLowerCase());
  if (found){ cachedRewardId = found.id; log('Helix: reward id =', found.id); }
  else log('Helix: reward с таким названием не найден (проверь точное имя)');
  return cachedRewardId;
}

async function fetchRedemptions(accessToken, broadcasterId, status){
  const rewardId = await getRewardId(accessToken, broadcasterId);
  if (!rewardId) return [];

  const url = new URL('https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions');
  url.searchParams.set('broadcaster_id', broadcasterId);
  url.searchParams.set('reward_id', rewardId);
  url.searchParams.set('status', status);          // UNFULFILLED / FULFILLED
  url.searchParams.set('first', '50');
  // url.searchParams.set('sort','NEWEST');        // опционально

  const r = await fetch(url, { headers:{
    'Client-ID': CLIENT_ID, 'Authorization':'Bearer '+accessToken
  }});
  if (!r.ok) return [];
  const j = await r.json();
  return j.data || [];
}

async function pollRedemptions(accessToken, broadcasterId){
  try{
    const arr1 = await fetchRedemptions(accessToken, broadcasterId, 'UNFULFILLED');
    const arr2 = await fetchRedemptions(accessToken, broadcasterId, 'FULFILLED'); // автоодобренные

    const all = [...arr1, ...arr2];
    if (!all.length) return;

    for (const it of all){
      if (seen.has(it.id)) continue;
      const t = Date.parse(it.redeemed_at || it.created_at || new Date().toISOString());
      // берём только те, что пришли ПОСЛЕ старта страницы (чтобы не сработать на «старые»)
      if (t < startedAt - 2000) continue;

      seen.add(it.id);
      lastSeenAt = Math.max(lastSeenAt, t);

      const title = (it.reward?.title || '').trim();
      log('Helix poll → Redemption:', title, 'by', it.user_login || it.user_name || '');
      if (title.toLowerCase() === REWARD_TITLE.trim().toLowerCase()){
        await triggerRandomSkill().then(()=>log('→ skill triggered (poll)'))
                                  .catch(e=>log('Trigger error (poll):', e.message));
      }
    }
  }catch(e){
    // не шумим в логах
  }
}

function startPolling(accessToken, broadcasterId){
  if (pollTimer) clearInterval(pollTimer);
  pollTimer = setInterval(()=> pollRedemptions(accessToken, broadcasterId), 5000);
}

// ───────────── Firestore: случайный из первых 5 ─────────────
async function triggerRandomSkill(){
  const { db, doc, getDoc, updateDoc, serverTimestamp } = await (async ()=> {
    const x = await ensureFirebase();
    return { db: x.db, doc: x.doc, getDoc: x.getDoc, updateDoc: x.updateDoc, serverTimestamp: x.serverTimestamp };
  })();

  try{
    const ref  = doc(db,'rooms',ROOM_ID);
    const snap = await getDoc(ref);
    if(!snap.exists()) throw new Error('room not found');
    const d = snap.data();
    const list = (d.actions||[]).slice(0,5).filter(x=>x?.label && Number(x?.dmg)>0);
    if(!list.length) throw new Error('no actions configured');

    const pick = list[Math.floor(Math.random()*list.length)];
    await updateDoc(ref, { cmd: { type:'damage', amount:Number(pick.dmg)||0, at: serverTimestamp() } });
  }catch(e){
    if (/permission/i.test(e.message) || /missing/i.test(e.message)){
      log('Нет прав писать в комнату. Войдите в Google под админом комнаты и попробуйте снова.');
    } else {
      log('Firestore error:', e.message);
    }
    throw e;
  }
}

// ───────────── boot ─────────────
(async ()=>{
  try{
    log('REDIRECT_URI:', REDIRECT_URI);

    ensureFirebase().catch(e=>log('Firebase init error:', e.message));

    const fromHash = parseHashToken();
    if (fromHash) sessionStorage.setItem('tw_access_token', fromHash);

    const accessToken = sessionStorage.getItem('tw_access_token');
    if (!accessToken){ log('Токен Twitch не найден. Нажми «Войти в Twitch».'); return; }

    await validateToken(accessToken).catch(()=>{});

    const user = await fetchUser(accessToken);
    log('Twitch:', user.display_name, `(id ${user.id})`);

    await connectEventSub(accessToken, user.id);
    connectPubSub(accessToken, user.id);
    startPolling(accessToken, user.id);               // ← теперь ловим и FULFILLED

    log(`Готово: ждём редемпы «${REWARD_TITLE}» …`);
  }catch(e){
    log('Ошибка:', e.message);
  }
})();
</script>
</body>
</html>
